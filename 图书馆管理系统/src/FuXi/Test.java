package FuXi;

/**
 * @author yolo
 * @date 2019/10/22-18:51
 * 1.类的加载：
 *      发生在运行时期
 *      把类从磁盘加载到内存
 *      用到时才会加载
 *
 *        1.从磁盘加载到内存：
 *            谁负责：类加载器ClassLoader
 *            从磁盘哪个位置记载：配置的方法（主要方式）--CLASSPATH环境变量
 *            加载到内存哪：方法区
 *       2.程序是一开始就进行类的加载吗：不是
 *            是按需加载（懒加载）   HashMap/Hashtable
 *            什么时候需要：
 *                构造对象；
 *                调用静态方法/访问静态的属性；
 *                反射
 *       3.类加载时会执行类的初始化
 *            执行静态属性的初始化
 *            执行静态代码块（按书写顺序）
 *
 *
 *修饰方法：
 *  没有static
 *      运行时期，在方法的调用时，调用栈，
 *什么时候用静态方法（总体的-与对象无关）或者非静态方法（某个对象的）
 *  main直接调用时，一般用静态的
 *
 *  extends：类的继承，接口的继承（可多继承），泛型定义时的边界，泛型使用时通配符的上界
 *  new实例化对象：
 *      对象的生命周期--是运行期间的概念，只有在运行期间才会用到代码
 *      生命周期：
 *          1.new关键字（可能触发类的加载）：①从方法区找相应的类，找不到就类的加载，②找到啦就计算对象的大小，③在堆中合适的位置申请空间，④memset(0x0)--属性的默认值
 *          2.三个初始化：int a=10;构造代码块;这两个整体先执行，两个之间谁先写先执行谁
 *                      构造方法--后执行   父类>子类
 *          3.真正的生命：正确使用在这个时期
 *          4.死去但保留尸体:未被GC回收
 *              谁是垃圾：---对象
 *              怎么判断谁是垃圾？
 *              够快速：   算法    快速回收--分类
 *
 * this:指向当前对象，调用构造方法
 * super：：调用父类的构造方法，访问父类的属性
 * instanceof操作符:引用 instanceof 类型（类/接口）
 * list instanceof List
 *  判断list指向的对象是否也能被List指向
 *throw：抛出异常
 *thy catch finally 捕获异常
 * throws 方法的异常列表，受检异常（必须）
 *                      非受查异常（可写可不写）
 */
public class Test {

}
