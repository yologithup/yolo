package 线程;

/**
 * @author yolo
 * @date 2019/11/19-16:11
 *线程通信：
 *  为什么要处理线程通信
 *      多个线程并发执行时，在默认情况下CPU时随机切换线程的，当我们休要多个线程共同来完成一件任务
 *      并且我们希望他们有规律的执行，那么线程之间需要一些协调通信，一次来达到线程共同操作同一份数据
 *  如何保证线程通信有效利用资源L:
 *      多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或者操作
 *      就是多个线程在操作同一份资源时，避免对统一共享变量的争夺。也就是我们需要通过一定的手段时各个线程
 *      能有效的利用资源。而这种手段即--等待幻唤醒机制
 *1.2 等待唤醒机制 什么是等待唤醒机制 这是多个线程间的一种协作机制。
 * 谈到线程我们经常想到的是线程间的竞争（race），
 * 比如去争夺锁，但这并不是 故事的全部，线程间也会有协作机制。
 * 就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，
 * 但更多时 候你们更多是一起合作以完成某些任务。
 * 就是在一个线程进行了规定操作后，就进入等待状态（wait()），
 * 等待其他线程执行完他们的指定代码过后 再将 其唤醒（notify()）;
 * 在有多个线程进行等待时，
 * 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。
 * wait/notify 就是线程间的一种协作机制。
 * 等待唤醒中的方法 等待唤醒机制就是用于解决线程间通信的问题的，
 * 使用到的3个方法的含义如下：
 *1. wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源
 * 也不会去竞争锁了，这时 的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作
 * 也即是“通知（notify）”在这个对象 上等待的线程从wait set 中释放出来
 * 重新进入到调度队列（ready queue）中 2. notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先 入座。 3. notifyAll：则释放所通知对象的 wait set 上的全部线程。 注意： 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而 此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调 用 wait 方法之后的地方恢复执行。 总结如下： 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态； 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态
 *
 */
public class Main04 {
    public static void main(String[] args) {

    }
}
